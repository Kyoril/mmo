// Copyright (C) 2019 - 2025, Kyoril. All rights reserved.

#include "player.h"

#include "player_manager.h"
#include "base/utilities.h"
#include "game_server/game_creature_s.h"
#include "game_server/game_object_s.h"
#include "game_server/game_player_s.h"
#include "game/spell_target_map.h"
#include "game_server/game_bag_s.h"
#include "proto_data/project.h"
#include "game/loot.h"

namespace mmo
{

	void Player::OnAutoStoreLootItem(uint16 opCode, uint32 size, io::Reader& contentReader)
	{
		uint8 lootSlot;
		if (!(contentReader >> io::read<uint8>(lootSlot)))
		{
			WLOG("Failed to read loot slot");
			return;
		}

		// TODO: Check current loot
		if (!m_loot)
		{
			WLOG("Player is not looting anything right now!");
			return;
		}

		// Check if the distance is okay
		if (m_lootSource &&
			m_lootSource->HasMovementInfo() &&
			m_character->GetSquaredDistanceTo(m_lootSource->GetPosition(), true) >= LootDistance * LootDistance)
		{
			// Distance is too big
			WLOG("Player tried to open loot of target which is too far away!");
			return;
		}

		const LootItem* lootItem = m_loot->GetLootDefinition(lootSlot);
		if (!lootItem)
		{
			WLOG("Loot slot is empty!");
			return;
		}

		// Already looted?
		if (lootItem->isLooted)
		{
			WLOG("Loot slot is already looted!");
			return;
		}

		const proto::ItemEntry* item = m_project.items.getById(lootItem->definition.item());
		if (!item)
		{
			WLOG("Unable to find item which was generated by loot definition! Game data might be corrupt...");
			return;
		}

		Inventory& inventory = m_character->GetInventory();

		std::map<uint16, uint16> addedBySlot;
		auto result = inventory.CreateItems(*item, lootItem->count, &addedBySlot);
		if (result != inventory_change_failure::Okay)
		{
			ELOG("Failed to add item to inventory: " << result);
			return;
		}

		for (auto& slot : addedBySlot)
		{
			OnItemAdded(slot.first, slot.second, true, false);

			if (m_character->GetGroupId() != 0)
			{
				m_character->ForEachSubscriberInSight([&slot, this](TileSubscriber& subscriber)
					{
						if (subscriber.GetGameUnit().GetGuid() == m_character->GetGuid())
						{
							return;
						}

						if (!subscriber.GetGameUnit().IsPlayer())
						{
							return;
						}

						auto& player = subscriber.GetGameUnit().AsPlayer();
						if (player.GetGroupId() == m_character->GetGroupId())
						{
							player.OnItemAdded(slot.first, slot.second, true, false);
						}
					});
			}
		}

		// Consume this item
		auto playerGuid = m_character->GetGuid();
		m_loot->TakeItem(lootSlot, playerGuid);
	}

	void Player::OnAutoEquipItem(uint16 opCode, uint32 size, io::Reader& contentReader)
	{
		uint8 srcBag, srcSlot;
		if (!(contentReader >> io::read<uint8>(srcBag) >> io::read<uint8>(srcSlot)))
		{
			WLOG("Failed to read source bag and slot");
			return;
		}

		auto& inv = m_character->GetInventory();
		auto absSrcSlot = Inventory::GetAbsoluteSlot(srcBag, srcSlot);
		auto item = inv.GetItemAtSlot(absSrcSlot);
		if (!item)
		{
			ELOG("Item not found");
			return;
		}

		uint8 targetSlot = 0xFF;

		// Check if item is equippable
		const auto& entry = item->GetEntry();
		switch (entry.inventorytype())
		{
		case inventory_type::Head:
			targetSlot = player_equipment_slots::Head;
			break;
		case inventory_type::Cloak:
			targetSlot = player_equipment_slots::Back;
			break;
		case inventory_type::Neck:
			targetSlot = player_equipment_slots::Neck;
			break;
		case inventory_type::Feet:
			targetSlot = player_equipment_slots::Feet;
			break;
		case inventory_type::Body:
			targetSlot = player_equipment_slots::Body;
			break;
		case inventory_type::Chest:
		case inventory_type::Robe:
			targetSlot = player_equipment_slots::Chest;
			break;
		case inventory_type::Legs:
			targetSlot = player_equipment_slots::Legs;
			break;
		case inventory_type::Shoulders:
			targetSlot = player_equipment_slots::Shoulders;
			break;
		case inventory_type::TwoHandedWeapon:
		case inventory_type::MainHandWeapon:
			targetSlot = player_equipment_slots::Mainhand;
			break;
		case inventory_type::OffHandWeapon:
		case inventory_type::Shield:
		case inventory_type::Holdable:
			targetSlot = player_equipment_slots::Offhand;
			break;
		case inventory_type::Weapon:
			targetSlot = player_equipment_slots::Mainhand;
			break;
		case inventory_type::Finger:
			targetSlot = player_equipment_slots::Finger1;
			break;
		case inventory_type::Trinket:
			targetSlot = player_equipment_slots::Trinket1;
			break;
		case inventory_type::Wrists:
			targetSlot = player_equipment_slots::Wrists;
			break;
		case inventory_type::Tabard:
			targetSlot = player_equipment_slots::Tabard;
			break;
		case inventory_type::Hands:
			targetSlot = player_equipment_slots::Hands;
			break;
		case inventory_type::Waist:
			targetSlot = player_equipment_slots::Waist;
			break;
		case inventory_type::Ranged:
		case inventory_type::RangedRight:
		case inventory_type::Thrown:
			targetSlot = player_equipment_slots::Ranged;
			break;
		default:
			if (entry.itemclass() == item_class::Container ||
				entry.itemclass() == item_class::Quiver)
			{
				for (uint16 slot = player_inventory_slots::Start; slot < player_inventory_slots::End; ++slot)
				{
					auto bag = inv.GetBagAtSlot(slot | 0xFF00);
					if (!bag)
					{
						targetSlot = slot;
						break;
					}
				}

				if (targetSlot == 0xFF)
				{
					//m_character->inventoryChangeFailure(game::inventory_change_failure::NoEquipmentSlotAvailable, item.get(), nullptr);
					return;
				}
			}
			break;
		}

		if (targetSlot == player_equipment_slots::Finger1 ||
			targetSlot == player_equipment_slots::Trinket1)
		{
			const auto itemAtTargetSlot = inv.GetItemAtSlot(Inventory::GetAbsoluteSlot(player_inventory_slots::Bag_0, targetSlot));
			if (itemAtTargetSlot)
			{
				const auto itemAtSecondSlot = inv.GetItemAtSlot(Inventory::GetAbsoluteSlot(player_inventory_slots::Bag_0, targetSlot + 1));
				if (!itemAtSecondSlot)
				{
					targetSlot++;
				}
			}
		}

		// Check if valid slot found
		auto absDstSlot = Inventory::GetAbsoluteSlot(player_inventory_slots::Bag_0, targetSlot);
		if (!Inventory::IsEquipmentSlot(absDstSlot) && !Inventory::IsBagPackSlot(absDstSlot))
		{
			ELOG("Invalid target slot: " << targetSlot);
			//m_character->inventoryChangeFailure(game::inventory_change_failure::ItemCantBeEquipped, item.get(), nullptr);
			return;
		}

		// Get item at target slot
		if (auto result = inv.SwapItems(absSrcSlot, absDstSlot); result != inventory_change_failure::Okay)
		{
			// Something went wrong
			ELOG("ERROR: " << result);
		}
	}

	void Player::OnAutoStoreBagItem(uint16 opCode, uint32 size, io::Reader& contentReader)
	{
		uint8 srcBag, srcSlot, dstBag;
		if (!(contentReader >> io::read<uint8>(srcBag) >> io::read<uint8>(srcSlot) >> io::read<uint8>(dstBag)))
		{
			WLOG("Failed to read source bag, source slot and destination bag");
			return;
		}

		// TODO
	}

	void Player::OnSwapItem(uint16 opCode, uint32 size, io::Reader& contentReader)
	{
		uint8 srcBag, srcSlot, dstBag, dstSlot;
		if (!(contentReader >> io::read<uint8>(srcBag) >> io::read<uint8>(srcSlot) >> io::read<uint8>(dstBag) >> io::read<uint8>(dstSlot)))
		{
			WLOG("Failed to read source bag, source slot, destination bag and destination slot");
			return;
		}

		auto& inv = m_character->GetInventory();
		auto result = inv.SwapItems(
			Inventory::GetAbsoluteSlot(srcBag, srcSlot),
			Inventory::GetAbsoluteSlot(dstBag, dstSlot));
		if (result)
		{
			ELOG("ERRROR: " << result);
		}
	}

	void Player::OnSwapInvItem(uint16 opCode, uint32 size, io::Reader& contentReader)
	{
		uint8 srcSlot, dstSlot;
		if (!(contentReader >> io::read<uint8>(srcSlot) >> io::read<uint8>(dstSlot)))
		{
			WLOG("Failed to read source slot and destination slot");
			return;
		}

		auto& inv = m_character->GetInventory();
		auto result = inv.SwapItems(
			Inventory::GetAbsoluteSlot(player_inventory_slots::Bag_0, srcSlot),
			Inventory::GetAbsoluteSlot(player_inventory_slots::Bag_0, dstSlot));
		if (result)
		{
			ELOG("ERRROR: " << result);
		}
	}

	void Player::OnSplitItem(uint16 opCode, uint32 size, io::Reader& contentReader)
	{
		uint8 srcBag, srcSlot, dstBag, dstSlot, count;
		if (!(contentReader >> io::read<uint8>(srcBag) >> io::read<uint8>(srcSlot) >> io::read<uint8>(dstBag) >> io::read<uint8>(dstSlot) >> io::read<uint8>(count)))
		{
			WLOG("Failed to read source bag, source slot, destination bag, destination slot and count");
			return;
		}

		// TODO
	}

	void Player::OnAutoEquipItemSlot(uint16 opCode, uint32 size, io::Reader& contentReader)
	{

	}

	void Player::OnDestroyItem(uint16 opCode, uint32 size, io::Reader& contentReader)
	{
		uint8 bag, slot, count;
		if (!(contentReader >> io::read<uint8>(bag) >> io::read<uint8>(slot) >> io::read<uint8>(count)))
		{
			WLOG("Failed to read bag, slot and count");
			return;
		}

		auto result = m_character->GetInventory().RemoveItem(Inventory::GetAbsoluteSlot(bag, slot), count);
		if (!result)
		{
			// TODO:
			ELOG("ERRROR: " << result);
		}
	}

	void Player::OnLoot(uint16 opCode, uint32 size, io::Reader& contentReader)
	{
		uint64 objectGuid;
		if (!(contentReader >> io::read<uint64>(objectGuid)))
		{
			WLOG("Failed to read object guid");
			return;
		}

		// Find game object
		GameObjectS* lootObject = m_character->GetWorldInstance()->FindObjectByGuid(objectGuid);
		if (!lootObject)
		{
			ELOG("Player tried to loot non existing object!");
			return;
		}

		m_character->CancelCast(spell_interrupt_flags::Any);
		m_character->LootObject(lootObject->shared_from_this());
	}

	void Player::OnLootMoney(uint16 opCode, uint32 size, io::Reader& contentReader)
	{
		if (!m_loot)
		{
			ELOG("Player tried to loot money without having a loot window open");
			return;
		}

		// Check if the distance is okay
		if (m_lootSource &&
			m_lootSource->HasMovementInfo() &&
			m_character->GetSquaredDistanceTo(m_lootSource->GetPosition(), true) >= LootDistance * LootDistance)
		{
			// Distance is too big
			WLOG("Player tried to open loot of target which is too far away!");
			return;
		}

		uint32 lootGold = m_loot->getGold();
		if (lootGold == 0)
		{
			WLOG("No gold to loot!");
			return;
		}

		// Check if it's a creature
		std::vector<std::shared_ptr<GamePlayerS>> recipients;
		if (m_lootSource->GetTypeId() == ObjectTypeId::Unit)
		{
			// If looting a creature, loot has to be shared between nearby group members
			std::shared_ptr<GameCreatureS> creature = std::dynamic_pointer_cast<GameCreatureS>(m_lootSource);
			creature->ForEachLootRecipient([&recipients](std::shared_ptr<GamePlayerS>& recipient)
				{
					recipients.push_back(recipient);
				});

			// If this fires, the creature has no loot recipients added. Please check CreatureAIDeathState::OnEnter!
			ASSERT(!recipients.empty());

			// Share gold
			lootGold /= recipients.size();
			if (lootGold == 0)
			{
				lootGold = 1;
			}
		}
		else
		{
			// We will be the only recipient
			recipients.push_back(m_character);
		}

		// Reward with gold
		for (const std::shared_ptr<GamePlayerS>& recipient : recipients)
		{
			uint32 coinage = recipient->Get<uint32>(object_fields::Money);
			if (coinage >= std::numeric_limits<uint32>::max() - lootGold)
			{
				coinage = std::numeric_limits<uint32>::max();
			}
			else
			{
				coinage += lootGold;
			}
			recipient->Set<uint32>(object_fields::Money, coinage);

			// Notify players
			if (std::shared_ptr<Player> player = m_manager.GetPlayerByCharacterGuid(recipient->GetGuid()))
			{
				if (recipients.size() > 1)
				{
					player->SendPacket([lootGold](game::OutgoingPacket& packet)
						{
							packet.Start(game::realm_client_packet::LootMoneyNotify);
							packet << io::write<uint32>(lootGold);
							packet.Finish();
						});
				}

				// TODO: Put this packet into the LootInstance class or in an event callback maybe
				if (m_lootSource &&
					m_lootSource->GetGuid() == m_loot->getLootGuid())
				{
					player->SendPacket([lootGold](game::OutgoingPacket& packet)
						{
							packet.Start(game::realm_client_packet::LootClearMoney);
							packet.Finish();
						});
				}
			}
		}

		// Take gold (WARNING: May reset m_loot as loot may become empty after this)
		m_loot->TakeGold();
	}

	void Player::OnLootRelease(uint16 opCode, uint32 size, io::Reader& contentReader)
	{
		uint64 objectGuid;
		if (!(contentReader >> io::read<uint64>(objectGuid)))
		{
			WLOG("Failed to read object guid");
			return;
		}

		if (m_lootSource &&
			m_lootSource->GetGuid() != objectGuid)
		{
			WLOG("Player tried to close loot dialog for object " << objectGuid << " which he didn't open!")
				return;
		}

		CloseLootDialog();
	}

	void Player::OnUseItem(uint16 opCode, uint32 size, io::Reader& contentReader)
	{
		uint8 bagId = 0, slotId = 0;
		uint64 itemGuid = 0;
		SpellTargetMap targetMap;
		if (!(contentReader
			>> io::read<uint8>(bagId)
			>> io::read<uint8>(slotId)
			>> io::read<uint64>(itemGuid)
			>> targetMap))
		{
			ELOG("Could not read packet");
			return;
		}

		// Get item
		auto item = m_character->GetInventory().GetItemAtSlot(Inventory::GetAbsoluteSlot(bagId, slotId));
		if (!item)
		{
			WLOG("Item not found! Bag: " << uint16(bagId) << "; Slot: " << uint16(slotId));
			return;
		}

		if (item->GetGuid() != itemGuid)
		{
			WLOG("Item GUID does not match. We look for " << log_hex_digit(itemGuid) << " but found " << log_hex_digit(item->GetGuid()));
			return;
		}

		auto& entry = item->GetEntry();

		// Find all OnUse spells
		for (int i = 0; i < entry.spells_size(); ++i)
		{
			const auto& spell = entry.spells(i);
			if (!spell.spell())
			{
				WLOG("No spell entry");
				continue;
			}

			// Spell effect has to be triggered "on use"
			if (spell.trigger() != item_spell_trigger::OnUse)
			{
				continue;
			}

			// Look for the spell entry
			const auto* spellEntry = m_project.spells.getById(spell.spell());
			if (!spellEntry)
			{
				WLOG("Could not find spell by id " << spell.spell());
				continue;
			}

			// Cast the spell
			uint64 time = spellEntry->casttime();
			SpellCastResult result = m_character->CastSpell(targetMap, *spellEntry, time, false, itemGuid);
			if (result != spell_cast_result::CastOkay)
			{
				SendPacket([itemGuid, &result, &spell](game::OutgoingPacket& packet)
					{
						packet.Start(game::realm_client_packet::SpellFailure);
						packet
							<< io::write_packed_guid(itemGuid)
							<< io::write<uint32>(spell.spell())
							<< io::write<GameTime>(GetAsyncTimeMs())
							<< io::write<uint8>(result);
						packet.Finish();
					});
			}
		}
	}
}