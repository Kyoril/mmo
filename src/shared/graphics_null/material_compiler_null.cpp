// Copyright (C) 2019 - 2025, Kyoril. All rights reserved.

#include "material_compiler_null.h"

namespace mmo
{
	void MaterialCompilerNull::AddGlobalFunction(std::string_view name, std::string_view code)
	{
	}

	ExpressionIndex MaterialCompilerNull::AddExpression(std::string_view code, ExpressionType type)
	{
		return IndexNone;
	}

	void MaterialCompilerNull::NotifyTextureCoordinateIndex(uint32 textureCoordinateIndex)
	{
	}
	
	ExpressionIndex MaterialCompilerNull::AddTextureCoordinate(int32 coordinateIndex)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddTextureSample(std::string_view texture, ExpressionIndex coordinates, bool srgb)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddMultiply(ExpressionIndex first, ExpressionIndex second)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddAddition(ExpressionIndex first, ExpressionIndex second)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddSubtract(ExpressionIndex first, ExpressionIndex second)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddLerp(ExpressionIndex first, ExpressionIndex second, ExpressionIndex alpha)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddDot(ExpressionIndex first, ExpressionIndex second)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddClamp(ExpressionIndex base, ExpressionIndex min, ExpressionIndex max)
	{
		return IndexNone;
	}
	
	ExpressionIndex MaterialCompilerNull::AddOneMinus(ExpressionIndex input)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddPower(ExpressionIndex base, ExpressionIndex exponent)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddWorldPosition()
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddCameraVector()
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddMask(ExpressionIndex input, bool r, bool g, bool b, bool a)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddVertexNormal()
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddDivide(ExpressionIndex first, ExpressionIndex second)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddAbs(ExpressionIndex input)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddNormalize(ExpressionIndex input)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddVertexColor()
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddAppend(ExpressionIndex first, ExpressionIndex second)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddTransform(ExpressionIndex input, Space sourceSpace, Space targetSpace)
	{
		return IndexNone;
	}

	void MaterialCompilerNull::GenerateVertexShaderCode(VertexShaderType type)
	{
		m_vertexShaderCode = "// This was generated by MaterialCompilerNull. It doesn't do anything.";
	}

	void MaterialCompilerNull::GeneratePixelShaderCode(PixelShaderType type)
	{
		m_pixelShaderCode[(int)type] = "// This was generated by MaterialCompilerNull. It doesn't do anything.";
	}

	ExpressionIndex MaterialCompilerNull::AddTextureParameterSample(std::string_view name, std::string_view texture,
		ExpressionIndex coordinates, bool srgb)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddScalarParameterExpression(std::string_view name, float defaultValue)
	{
		return IndexNone;
	}

	ExpressionIndex MaterialCompilerNull::AddVectorParameterExpression(std::string_view name,
		const Vector4& defaultValue)
	{
		return IndexNone;
	}
}
